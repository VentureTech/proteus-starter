/*
                        Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

package com.example.app.support.address;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import org.apache.commons.lang.StringUtils;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.example.app.support.address.AddressComponent.*;
import static com.example.app.support.address.AddressRegexLibrary.*;
//CHECKSTYLE:OFF

//: support theses
//123 Avenue of art, philadelphia pa 12345
//PO box 123, abc city, ca 24656
//123 Route 29 South, new jersey, 12323  

/**
 * Address parser
 *
 * @author jliang
 */
public class AddressParser
{

    private static final Pattern CORNER = Pattern.compile(P_CORNER.getRegex());
    private static final Pattern STREET_ADDRESS = Pattern.compile(P_STREET_ADDRESS.getRegex());
    private static final Pattern CSZ = Pattern.compile(P_CSZ.getRegex());
    private static final Pattern INTERSECTION = Pattern.compile(P_INTERSECTION.getRegex());
    private static final Pattern CLEANUP = Pattern.compile("^\\W+|\\W+$|[\\s\\p{Punct}&&[^\\)\\(#&,:;@'`-]]");
    private static final Pattern STREET_TYPES = Pattern.compile(RegexLibrary.STREET_DESIGNATOR);
    private static final Pattern STATES = Pattern.compile(RegexLibrary.US_STATES);
    //: document this craziness
    private static final Pattern STREET_DESIGNATOR_CHECK = Pattern.compile("\\b(?i:(?:" + RegexLibrary.STREET_DESIGNATOR + "))\\b");
    //code used to replace hashcodes so they don't get removed by the address parser
    private static final String HASHCODE_VALUE = "48914631374";

    /**
     * Parses a raw address string, this delegates to {@linkplain AddressParser#parseAddress(String, boolean)}
     * with autoCorrectStateSpelling set to false
     *
     * @param rawAddr the raw address
     *
     * @return a map of parsed address components
     */
    public static Map<AddressComponent, String> parseAddress(String rawAddr)
    {
        return parseAddress(rawAddr, true);
    }

    /**
     * This is the main method that calls all the other method
     * to successfully split up and address into separate fields.
     *
     * Returns a string key,value map containing address parts
     * along with their string values.
     *
     * @param address the address.
     * @param autoCorrectStateSpelling flag to autocorrect spelling.
     *
     * @return the parsed mapping.
     */
    @Nonnull
    public static Map<AddressComponent, String> parseAddress(String address, boolean autoCorrectStateSpelling)
    {

        /*First we replace individual fields with temporary escaped value.
         * The reason we do this separately is because we can
         * strip out certain characters in the split up fields more accurately than
         * in the constructed address (commas for instance can easily be stripped out of
         * the split up fields, but are important to maintain in the address)
        */

        // There are some words that we want to remove / permanently change in the address (undefined / undefd)
        Map<String, String> replacementStrings = getReplacementStrings();
        address = escapeString(address, replacementStrings);

        // create the map of regexp string to temporarily replace with fillers, since the addressparser doesn't like them
        HashBiMap<String, String> constStringMap = setupConstStringMap();

        // create the map of regexp string to temporarily replace with fillers, since the addressparser doesn't like them
        HashBiMap<String, String> regexpStringMap = formatRegexpStringMap();

        // create the map of regexp strings that we explicitly do not want to escape
        HashBiMap<String, String> doNotEscapeRegexpStringMap = formatdoNotEscapeRegexpStringMap();

        // Store the strings that we do not want to escape
        HashBiMap<String, String> doNotEscapeFilledStringMap = getMatchingStrings(address, doNotEscapeRegexpStringMap);

        // temporarily move the parts of the string that we explicitly do not want to escape
        address = escapeString(address, doNotEscapeRegexpStringMap);

        // Store the strings that match the regular expression fillers in the map for replacement later
        HashBiMap<String, String> filledRegexpStringMap = getMatchingStrings(address, regexpStringMap);

        // replace the strings that match within the address with fillers
        address = escapeString(address, filledRegexpStringMap);
        address = escapeString(address, constStringMap);

        // Put the strings we do not want to escape back in
        address = escapeString(address, doNotEscapeFilledStringMap.inverse());

        // parse the address into separate fields
        Map<AddressComponent, String> results = prepareAddressForParsingAndParse(address, autoCorrectStateSpelling);

        if (results == null)
        {
            // there was a problem parsing the address
            return new EnumMap<>(AddressComponent.class);
        }

        // Replace the fillers in the split up fields with the original values (requires an inverse)
        results = replaceOriginalStringsInSplitUpFields(results, filledRegexpStringMap.inverse());
        results = replaceOriginalStringsInSplitUpFields(results, constStringMap.inverse());

        return results;
    }

    /**
     * Returns a map containing strings that we want to permanently
     * replace within the address.
     *
     * Note -- since this map reuses the code in escapeString(),
     * the replacement keys are CaSe SENsitIVE
     *
     * @return replacement strings.
     */
    private static Map<String, String> getReplacementStrings()
    {
        Map<String, String> replacementMap = new HashMap<>();
        replacementMap.put("Undefined", "TBD"); // replace Undefined with TBD
        replacementMap.put("undefined", "TBD"); // replace undefined with TBD
        replacementMap.put("UNDEFINED", "TBD"); // replace undefined with TBD
        replacementMap.put(" Undefd", ""); // remove Undefd
        replacementMap.put(" undefd", ""); // remove undefd
        replacementMap.put("County Road", "CR"); // Change County Road to CR
        replacementMap.put("county road", "CR");
        return replacementMap;
    }

    /**
     * This method takes a map of Strings that need to
     * be replaced in the address, along with the fillvalues/escape values
     * they will temporarily be replaced with. The strings
     * have to be replaced before the addressparser looks
     * at them because it gets confused on these strings.
     *
     * Next, the map is iterated through and all instances
     * of the strings in address are replaced with their
     * fill values.
     *
     * @param stringToEscape string to escape.
     * @param codeMaps code maps.
     *
     * @return the escaped.
     */
    private static String escapeString(String stringToEscape, Map<String, String> codeMaps)
    {
        if (stringToEscape == null)
        {
            return stringToEscape;
        }
        for (String key : codeMaps.keySet())
        {
            // temporarily substitute strings that the address parser gets confused on
            stringToEscape = stringToEscape.replaceAll(key, codeMaps.get(key));
        }
        return stringToEscape;
    }

    /**
     * Setup String fill value bimap. That is, a bidirectional
     * map of Strings that we use to temporarily insert
     * fill values into the address so that the address parser
     * doesn't get confused.
     *
     * @return mapping.
     */
    private static HashBiMap<String, String> setupConstStringMap()
    {
        // bidi map to hold string to string mappings
        HashBiMap<String, String> constStrings = HashBiMap.create();

        // Replaces slashes with a temporary string replacement, since the addressparser doesn't get along with them
        constStrings.put("/", "21421161");

        // The address parser gets confused with TBD as an street number, so we replace it with a temporary number
        constStrings.put("TBD", "112521521");
        constStrings.put("Tbd", "4654231");
        constStrings.put("TBD", "9784261");

        // The address parser sometimes removes hashes
        constStrings.put("#", HASHCODE_VALUE);

        constStrings.put("Us Hwy", "Hwy Us28409182");
        constStrings.put("US HWY", "Hwy Us8123754741");
        return constStrings;
    }

    /**
     * Setup RegularExpression fill value bimap. That is, a bidirectional
     * map of regular expressions that we use to temporarily insert
     * fill values into the address so that the address parser
     * doesn't get confused.
     *
     * @return mapping.
     */
    private static HashBiMap<String, String> formatRegexpStringMap()
    {
        // bidi map to hold string to regular expression mappings
        // Notice the parantheses around the part that we are temporarily replacing (group)
        // -- these normally do no include surrounding spaces
        HashBiMap<String, String> regexpStrings = HashBiMap.create();

        // remove letter number/number from this address as in "2533 G 3/8 Road"
        regexpStrings.put(" ([a-zA-Z] \\d[\\/-]\\d)", "regexpCode1");

        // remove interstate from this address as in "2880, I-70 Business Loop"
        regexpStrings.put(" ([iI]-\\d+) ", "regExpCode2");


        // remove periods from the middle of words / numbers
        regexpStrings.put("\\s?(\\s*#?\\w+(\\.\\w+)+)", "522597205");

        // remove commas from the middle of words / numbers
        regexpStrings.put("\\s?(\\s*#?\\w+(,\\w+)+)", "784561789");

        // "(Fp-f-1)- 68-1371 Kinzel Place"
        // remove dashes from the middle of words / numbers
        regexpStrings.put("\\s?((\\-?\\s*#?(\\w+\\-\\w*)|(\\w*\\-\\w+))+)", "189237654");

        //555 Rivergate Lane #B1-104
        //Wheeler Circle 314D-6

        /*
        "(Fp-f-1- 68-1371 Kinzel Place"
        "abc-abc abc-abc"
        "abc- abc-"
        "-abc -abc"*/
        return regexpStrings;
    }

    /**
     * Generates a bi-map of regular reg expressions that we don't want to escape
     *
     * @return mapping
     */
    private static HashBiMap<String, String> formatdoNotEscapeRegexpStringMap()
    {
        HashBiMap<String, String> savedRegexpStrings = HashBiMap.create();

        // We don't want to escape dashes in zip codes
        savedRegexpStrings.put("(\\d{5}\\-\\d{4})", "zipCodeRegExp");

        return savedRegexpStrings;
    }

    /**
     * This method stores the strings that match regular
     * expressions in the regular expression map and
     * returns a map containing the strings as well as
     * the fill values they are being replaced with.
     *
     * @param address the address.
     * @param regexpMap regex mapping.
     *
     * @return results.
     */
    private static HashBiMap<String, String> getMatchingStrings(String address, Map<String, String> regexpMap)
    {
        HashBiMap<String, String> matchingStrings = HashBiMap.create();
        for (String key : regexpMap.keySet())
        {
            Pattern p = Pattern.compile(key);
            Matcher m = p.matcher(address);
            boolean matching = m.find();

            if (matching)
            {
                String from = m.group(1);
                String to = regexpMap.get(key);
                matchingStrings.put(from, to);
            }
            /*if (m.find())
            {
                // If there are two of these regex patterns in the address this may cause an error,
                // as only one will be replaced by the filler string

                logger.debug("~~~Warning~~~ -- multiple matches found for regexp: " + key + "\n" +
                        "On address: " + address);
            }*/
        }
        return matchingStrings;
    }

    /**
     * Passes the address to the jgeocoder address parser and
     * formats the results into a string map. Also handles
     * the strange case of highways -- that is, street type
     * PRECEDING street_number.
     *
     * @param address the address
     * @param autoCorrectSpelling flag.
     *
     * @return the results.
     */
    private static Map<AddressComponent, String> prepareAddressForParsingAndParse(String address, boolean autoCorrectSpelling)
    {
        Map<AddressComponent, String> results = jGeocodeParseAddress(address, autoCorrectSpelling);
        if (results == null)
        {
            return null; // Something went wrong in the process of parsing the address
        }

        String splitStreetNumber = results.get(NUMBER);
        String splitStreetDir = results.get(PREDIR);
        String splitStreetName = results.get(STREET);
        String splitStreetType = results.get(TYPE);
        String splitUnitNumber = results.get(LINE2);

        Collection<String> streetDirs = getStreetDirs();

        /* if the street name is a direction then chances
         * are that the street direction was pulled into
         * the street name incorrectly and the street name
         * is in the unit number (following conditional)
         */
        if (splitStreetName != null && streetDirs.contains(splitStreetName.toLowerCase()) && splitStreetDir == null)
        {
            splitStreetDir = splitStreetName;
            splitStreetName = null;
        }

        // We need to do some switching if the street name is null (usually a result of Hwy 19 or Road 5)
        // -- Second case --> Or if street type is null and unit number is non null we assume that part of the street
        // name got pulled into the unit number
        if ((splitStreetName == null && splitStreetType != null && splitUnitNumber != null) ||
            (splitStreetType == null && splitUnitNumber != null))
        {
            if (splitStreetName == null)
            {
                splitStreetName = "";
            }

            // if we have a street type then we are going to want to pull in
            // the first part of the unit number into street name (e.g. hwy 19 or road 52)
            if (splitStreetType != null)
            {
                Pattern p1 = Pattern.compile("^\\s?(\\S+)\\s?");
                Matcher m1 = p1.matcher(splitUnitNumber);

                if (m1.find())
                {
                    String streetTypePart = m1.group(1);
                    splitStreetName = createStreetName(splitStreetName, splitStreetType, streetTypePart);
                    splitUnitNumber = splitUnitNumber.substring(m1.end(0));
                    // since we pulled in the street type we don't want to pull it in again if the next matcher matches
                    splitStreetType = null;
                }
            }

            // Get the indexes of unit or a hash mark as clues for where to split
            int unitIndex = splitUnitNumber.toLowerCase().indexOf("unit");
            int hashIndex = splitUnitNumber.indexOf(HASHCODE_VALUE);


            // Part of the unit number to be removed and added to street name
            String partOfStreetName = "";
            // We want to leave the part of the unit number that has a hash mark or the string "unit"
            // in the unit number
            if (unitIndex != -1 || hashIndex != -1)
            {
                if (unitIndex != -1)
                {

                    if (unitIndex == 0) // Unit number starts with a # so the whole unit number stays as the unit number
                    {
                        partOfStreetName = "";
                    }
                    else
                    {
                        partOfStreetName = splitUnitNumber.substring(0, unitIndex - 1);
                    }
                    splitUnitNumber = splitUnitNumber.substring(unitIndex);
                }
                else
                {
                    if (hashIndex == 0) // Unit number starts with a # so the whole unit number stays as the unit number
                    {
                        partOfStreetName = "";
                    }
                    else
                    {
                        partOfStreetName = splitUnitNumber.substring(0, hashIndex - 1);
                    }
                    splitUnitNumber = splitUnitNumber.substring(hashIndex);
                }
                splitStreetName = createStreetName(splitStreetName,
                    splitStreetType, partOfStreetName);
            }
            else // We can't find any clues regarding what part of the unit number is actually the unit number
            {
                // Pattern to get the last string so we can look at it to see if it looks like a unit number
                // We assume that any string less than 3 characters or that is a number is a unit number
                Pattern p2 = Pattern.compile("\\s?(\\S+)$");
                Matcher m2 = p2.matcher(splitUnitNumber);

                if (m2.find())
                {
                    // the last word in the unit number is what we look at to try to guess
                    // whether it is a unit number
                    String lastWord = m2.group(1);
                    if (lastWord.length() < 3 || isNumeric(lastWord))
                    {
                        partOfStreetName = splitUnitNumber.substring(0, m2.start(0));
                        splitStreetName = createStreetName(splitStreetName,
                            splitStreetType, partOfStreetName);
                        splitUnitNumber = lastWord;
                    }
                    else
                    {
                        splitStreetName += ' ' + splitUnitNumber;
                        splitUnitNumber = null;
                    }
                }
            }
            // Either streetType was pulled into streetName or it started as null so it should be null
            splitStreetType = null;

            // set splitUnitNumber to null if it's empty
            if (splitUnitNumber != null && splitUnitNumber.isEmpty())
            {
                splitUnitNumber = null;
            }
        }


        results.put(NUMBER, splitStreetNumber);
        results.put(PREDIR, splitStreetDir);
        results.put(STREET, splitStreetName);
        results.put(TYPE, splitStreetType);
        results.put(LINE2, splitUnitNumber);

        return results;
    }

    /**
     * This method takes a map containing fill values that were
     * temporarily inserted into the address, mapped to
     * the strings that they originally replaced. Next, this
     * method iterates through the split up street fields and
     * replaces instances of the fillvalues with their originals.
     *
     * @param results parse results.
     * @param codeMaps code maps.
     *
     * @return the parse results.
     */

    private static Map<AddressComponent, String> replaceOriginalStringsInSplitUpFields(Map<AddressComponent, String> results,
        BiMap<String, String> codeMaps)
    {
        for (String oldString : codeMaps.keySet()) // contains a map of the form <stringToBeReplaced><StringToReplaceWith>
        {

            for (AddressComponent fieldKey : results.keySet())
            {
                if (results.get(fieldKey) == null) // only update fields that are not null
                {
                    continue;
                }
                else
                {
                    String originalString = results.get(fieldKey);
                    String updatedString = originalString.replaceAll(oldString, codeMaps.get(oldString));
                    results.put(fieldKey, updatedString);
                }
            }
        }
        return results;
    }

    /**
     * Parses a raw address string
     *
     * @param rawAddr the raw address
     * @param autoCorrectStateSpelling swith on/off auto correction on state mis-spelling
     *
     * @return a map of parsed address components
     */
    private static Map<AddressComponent, String> jGeocodeParseAddress(String rawAddr, boolean autoCorrectStateSpelling)
    {
        rawAddr = getCleanSttring(rawAddr);
        if (autoCorrectStateSpelling)
        {
            rawAddr = SpellingCorrector.correctStateSpelling(rawAddr);
        }
        Matcher m = STREET_ADDRESS.matcher(rawAddr);
        Map<AddressComponent, String> ret = null;
        if (m.matches())
        {
            ret = getAddrMap(m, P_STREET_ADDRESS.getNamedGroupMap());
            postProcess(ret);
            String splitRawAddr = null;
            String line12sep = ret.get(TLID);//HACK!
            if (!line12sep.contains(",")
                && (splitRawAddr = designatorConfusingCitiesCorrection(ret, rawAddr)) != null)
            {
                m = STREET_ADDRESS.matcher(splitRawAddr);
                if (m.matches())
                {
                    ret = getAddrMap(m, P_STREET_ADDRESS.getNamedGroupMap());
                    ret.remove(TLID);//HACK!
                    return ret;
                }
            }
            ret.remove(TLID);//HACK!
        }
        m = CORNER.matcher(rawAddr);
        if (ret == null && m.find())
        {
            m = INTERSECTION.matcher(rawAddr);
            if (m.matches())
            {
                ret = getAddrMap(m, P_INTERSECTION.getNamedGroupMap());
            }
        }

        if (ret == null)
        {
            m = CSZ.matcher(rawAddr);
            if (m.matches())
            {
                ret = getAddrMap(m, P_CSZ.getNamedGroupMap());
            }
        }
        return ret;
    }

    private static Collection<String> getStreetDirs()
    {

        Collection<String> streetDirs = new ArrayList<>();
        streetDirs.add("e");
        streetDirs.add("w");
        streetDirs.add("n");
        streetDirs.add("s");
        streetDirs.add("sw");
        streetDirs.add("nw");
        streetDirs.add("se");
        streetDirs.add("ne");

        return streetDirs;
    }

    /**
     * Creates the street name from the summation of the original
     * streetName + streetType (if non null) + part of the street
     * name split off from the unit number
     *
     * @param splitStreetName split
     * @param splitStreetType split
     * @param partOfStreetName part
     *
     * @return street name
     */
    private static String createStreetName(String splitStreetName,
        String splitStreetType, String partOfStreetName)
    {

        String addSpace = " ";
        String addPartSpace = " ";
        if (splitStreetName.isEmpty() || splitStreetType == null)
        {
            addSpace = ""; // don't add a space if the streetNumber is null
        }

        if (partOfStreetName.isEmpty())
        {
            addPartSpace = ""; // don't add a space if partOfStreetName is null or if we don't have a street type
        }

        if (splitStreetType == null)
        {
            splitStreetName += addPartSpace + partOfStreetName;
        }
        else
        {
            splitStreetName += addSpace + splitStreetType + addPartSpace + partOfStreetName;
        }
        return splitStreetName;
    }

    private static boolean isNumeric(String str)
    {
        for (char c : str.toCharArray())
        {
            if (!Character.isDigit(c)) return false;
        }
        return true;
    }

    private static String getCleanSttring(String rawAddr)
    {
        return CLEANUP.matcher(rawAddr).replaceAll(" ").replaceAll("\\s+", " ").trim();
    }

    private static Map<AddressComponent, String> getAddrMap(Matcher m, Map<Integer, String> groupMap)
    {
        Map<AddressComponent, String> ret = new EnumMap<>(AddressComponent.class);
        for (int i = 1; i <= m.groupCount(); i++)
        {
            String name = groupMap.get(i);
            AddressComponent comp = valueOf(name);
            if (ret.get(comp) == null)
            {
                putIfNotNull(ret, comp, m.group(i));
            }
        }
        return ret;
    }

    private static void postProcess(Map<AddressComponent, String> m)
    {
        //these are (temporary?) hacks...
        if (m.get(TYPE) == null && m.get(STREET) != null
            && STREET_TYPES.matcher(m.get(STREET).toUpperCase()).matches())
        {
            m.put(TYPE, m.get(STREET));
            m.put(STREET, m.get(PREDIR));
            m.put(PREDIR, null);
        }
        if (m.get(STATE) == null && m.get(LINE2) != null
            && STATES.matcher(m.get(LINE2).toUpperCase()).matches())
        {
            m.put(STATE, m.get(LINE2));
            m.put(LINE2, null);
        }
    }

    private static String designatorConfusingCitiesCorrection(Map<AddressComponent, String> parsedLocation, String input)
    {
        String street = parsedLocation.get(STREET);
        String type = parsedLocation.get(TYPE);
        String line2 = parsedLocation.get(LINE2);
        if (street == null || type == null || line2 != null || street.split(" ").length < 2)
        {
            return null;
        }
        Matcher m = STREET_DESIGNATOR_CHECK.matcher(street);
        if (m.find())
        {
            String parsedstate = parsedLocation.get(STATE);
            if (parsedstate == null)
            {
                String parsedcity = parsedLocation.get(CITY);
                if (parsedcity != null && parsedcity.length() == 2)
                {
                    parsedstate = parsedcity;
                }
            }
            String normalizedState = AddressStandardizer.normalizeState(StringUtils.upperCase(parsedstate));
            String inputUpper = input.toUpperCase();
            String ret = null;
            Set<String> stateSet = new HashSet<>();
            if (normalizedState != null)
            {
                stateSet.add(normalizedState);
            }
            else
            { //if no state in put, this needs to work much harder
                stateSet.addAll(SpecialData.C_MAP.keySet());
            }
            int stateIdx = parsedstate == null ? input.length() : input.lastIndexOf(parsedstate);
            for (String state : stateSet)
            {
                for (String s : SpecialData.C_MAP.get(state))
                {
                    int idx = -1;
                    if ((idx = inputUpper.lastIndexOf(s)) != -1)
                    { //and the input has one of the city names that can confuse the parser
                        //this almost guaranteed to break the parser, help the parser by putting a comma separator before the city
                        if (idx + s.length() >= stateIdx - 2)
                        {
                            return input.substring(0, idx) + ',' + input.substring(idx);
                        }
                    }
                }
            }
            return ret;
        }
        return null;

    }

    private static void putIfNotNull(Map<AddressComponent, String> m, AddressComponent ac, String v)
    {
        if (v != null)
            m.put(ac, v);
    }
}